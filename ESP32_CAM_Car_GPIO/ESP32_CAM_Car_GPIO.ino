/**
 * 2021/05/30 revised DRV_A/DIR_A/DRV_B/DIR_B pin#
 * 2021/06/10 added BT CAR support. need to disable ArduinoOTA due to resource conflict.
 * 2021/06/10 enabled OLED support, remap UART IO3/1 to SCL/SDA, disable serial.
 * 
 * 
 */
#include "esp_camera.h"
#include <WiFi.h>
// #include <ArduinoOTA.h>
#include "BluetoothSerial.h"
#include <Arduino.h>

#define ESP32_OLED

#define BT_CAR

#ifdef BT_CAR
#define BT_NAME "BT_CAMCAR_03"
#endif

/* Wifi Crdentials */
String sta_ssid = "YOUR_SSID";     // set Wifi network you want to connect to
String sta_password = "YOUR_PASSWORD";   // set password for Wifi network

#ifdef ESP32_OLED
#include <U8g2lib.h>
// [2021/06/11] use IO 3/1 for SW SCL/SDA
#define ESP32_SCL 3
#define ESP32_SDA 1
U8G2_SSD1306_128X64_NONAME_1_SW_I2C u8g2(U8G2_R0, /* clock=*/ESP32_SCL, /* data=*/ESP32_SDA, /* reset=*/ U8X8_PIN_NONE);  //ESP8266板子搭配SSD1306用這行

#define imgWidth 128
#define imgHeight 48  // use 48 for imge, the header in 16 is for text output.

static const unsigned char PROGMEM android[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xfc, 0x3f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0xff, 0xff, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xe0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x07, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xe0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x07, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xf0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xe0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x07, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xe0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x07, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xc0, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xe3, 0x03, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x80, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x01, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1f, 0xf8, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1f, 0xf8, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1f, 0xf8, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1f, 0xf8, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1f, 0xf8, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1f, 0xf8, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1f, 0xf8, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1f, 0xf8, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1f, 0xf8, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x1f, 0xf8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x0f, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x07, 0xe0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,};
#endif



/* define CAMERA_MODEL_AI_THINKER */
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22



#ifdef BT_CAR
// 2021/06/10 add BT Car & BlueToothSerial support
BluetoothSerial SerialBT;

int CAR_STATE=0;
#define CAR_FORWARD 1
#define CAR_BACK    2
#define CAR_LEFT    3
#define CAR_RIGHT   4
#define CAR_STOP    0

#define LED_YELLOW 12
#define LED_RED   13
#define LED_BLUE  15
int LED_BUILTIN = 16;
#define IN1 12
#define IN2 13
#define IN3 15
#define IN4 14

#endif

/* Defining motor and servo pins */
extern int DRV_A = 12;
extern int DIR_A = 13;
extern int DRV_B = 15;
extern int DIR_B = 14;



extern int ledVal = 20;  // setting bright of flash LED 0-255

extern int ledPin = 4;  // set digital pin GPIO4 as LED pin (use biult-in LED)
extern int buzzerPin = 2;  // set digital pin GPIO2 as LED pin (use Active Buzzer)
extern int servoPin = 2;  // set digital pin GPIO2 as servo pin (use SG90)

unsigned long previousMillis = 0;

void startCameraServer();

void initServo() {
  ledcSetup(8, 50, 16); /*50 hz PWM, 16-bit resolution and range from 3250 to 6500 */
  ledcAttachPin(servoPin, 8);
}

void initLed() {
  ledcSetup(7, 5000, 8); /* 5000 hz PWM, 8-bit resolution and range from 0 to 255 */
  ledcAttachPin(ledPin, 7);
}

void setup() {
  
#ifndef ESP32_OLED
  Serial.begin(115200);         // set up seriamonitor at 115200 bps
  Serial.setDebugOutput(true);
#endif  

#ifdef BT_CAR
  SerialBT.begin(BT_NAME);      //Bluetooth device name
#endif  

#ifdef ESP32_OLED
  u8g2.begin(); 
  Serial.setDebugOutput(false);
#endif
  
  Serial.println();
  Serial.println("*ESP32 Camera Remote Control");
  Serial.println("--------------------------------------------------------");

  // Set all the motor control pin to Output
  pinMode(DRV_A, OUTPUT);
  pinMode(DRV_B, OUTPUT);
  pinMode(DIR_A, OUTPUT);
  pinMode(DIR_B, OUTPUT);
  
  pinMode(ledPin, OUTPUT); // set the LED pin as an Output
  pinMode(buzzerPin, OUTPUT); // set the buzzer pin as an Output
  pinMode(servoPin, OUTPUT); // set the servo pin as an Output

  // Initial state - turn off motors, LED & buzzer
  digitalWrite(DRV_A, LOW);
  digitalWrite(DRV_B, LOW);
  digitalWrite(DIR_A, LOW);
  digitalWrite(DIR_B, LOW);
  digitalWrite(ledPin, LOW);
  digitalWrite(buzzerPin, LOW);
  digitalWrite(servoPin, LOW);

  /* Initializing Servo and LED */
  initServo();
  initLed();
  
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;
  //init with high specs to pre-allocate larger buffers
  if(psramFound()){
    config.frame_size = FRAMESIZE_UXGA;
    config.jpeg_quality = 10;
    config.fb_count = 2;
  } else {
    config.frame_size = FRAMESIZE_SVGA;
    config.jpeg_quality = 12;
    config.fb_count = 1;
  }

  // camera init
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    return;
  }

  //drop down frame size for higher initial frame rate
  sensor_t * s = esp_camera_sensor_get();
  s->set_framesize(s, FRAMESIZE_QVGA);

  // Set NodeMCU Wifi hostname based on chip mac address
  char chip_id[15];
  snprintf(chip_id, 15, "%04X", (uint16_t)(ESP.getEfuseMac()>>32));
  String hostname = "esp32cam-" + String(chip_id);

  Serial.println();
  Serial.println("Hostname: "+hostname);

  // first, set NodeMCU as STA mode to connect with a Wifi network
  WiFi.mode(WIFI_STA);
  WiFi.begin(sta_ssid.c_str(), sta_password.c_str());
  Serial.println("");
  Serial.print("Connecting to: ");
  Serial.println(sta_ssid);
  Serial.print("Password: ");
  Serial.println(sta_password);

  // try to connect with Wifi network about 10 seconds
  unsigned long currentMillis = millis();
  previousMillis = currentMillis;
  while (WiFi.status() != WL_CONNECTED && currentMillis - previousMillis <= 10000) {
    delay(500);
    Serial.print(".");
    currentMillis = millis();
  }

  // if failed to connect with Wifi network set NodeMCU as AP mode
  IPAddress myIP;
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("");
    Serial.println("*WiFi-STA-Mode*");
    Serial.print("IP: ");
    myIP=WiFi.localIP();
    Serial.println(myIP);
    delay(2000);
  } else {
    WiFi.mode(WIFI_AP);
    WiFi.softAP(hostname.c_str());
    myIP = WiFi.softAPIP();
    Serial.println("");
    Serial.println("WiFi failed connected to " + sta_ssid);
    Serial.println("");
    Serial.println("*WiFi-AP-Mode*");
    Serial.print("AP IP address: ");
    Serial.println(myIP);
    delay(2000);
  }

#ifdef ESP32_OLED
  u8g2.setFont(u8g2_font_helvB12_te);
  u8g2.firstPage();
  do {
      if (WiFi.status() == WL_CONNECTED)
        u8g2.drawStr(0, 13, WiFi.localIP().toString().c_str()); //output msg
        
      u8g2.drawXBMP(0,16, imgWidth, imgHeight, android);        //show image
  } while ( u8g2.nextPage() );
#endif  

  // Start camera server to get realtime view
  startCameraServer();
  Serial.print("Camera Ready! Use 'http://");
  Serial.print(myIP);
  Serial.println("' to connect ");

  // ArduinoOTA.begin();   // enable to receive update/upload firmware via Wifi OTA
}

#ifdef BT_CAR
void MotorUp()  {
  if (CAR_STATE==CAR_FORWARD)  return;
  CAR_STATE=CAR_FORWARD;
  Serial.println("Motor::Up");
  digitalWrite(DRV_A, LOW);
  digitalWrite(DIR_A, HIGH);
  digitalWrite(DRV_B, HIGH);
  digitalWrite(DIR_B, LOW);
  
  //ledcWrite(1, 255);
  //ledcWrite(2, 255);
  //MotorStop();
}

void MotorDown() {
  if (CAR_STATE==CAR_BACK)  return;
  CAR_STATE=CAR_BACK;
  Serial.println("Motor::Down");
  
  digitalWrite(DRV_A, HIGH);
  digitalWrite(DIR_A, LOW);
  digitalWrite(DRV_B, LOW);
  digitalWrite(DIR_B, HIGH);
  
  //ledcWrite(1, 255);
  //ledcWrite(2, 255);
  //MotorStop();
}

void MotorLeft() {
  if (CAR_STATE==CAR_LEFT)  return;
  CAR_STATE=CAR_LEFT;
  Serial.println("Motor::Left");
  digitalWrite(DRV_A, LOW);
  digitalWrite(DIR_A, LOW);
  digitalWrite(DRV_B, HIGH);
  digitalWrite(DIR_B, LOW);
  //MotorStop();
}

void MotorRight() {
  if (CAR_STATE==CAR_RIGHT)  return;
  CAR_STATE=CAR_RIGHT;
  Serial.println("Motor::Right");
  digitalWrite(DRV_A, LOW);
  digitalWrite(DIR_A, LOW);
  digitalWrite(DRV_B, LOW);
  digitalWrite(DIR_B, HIGH);
  //MotorStop();
}

void MotorStop() {
  if (CAR_STATE==CAR_STOP)  return;
  CAR_STATE=CAR_STOP;
  Serial.println("Motor::Stop");
  digitalWrite(IN1, LOW);   
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);   
  digitalWrite(IN4, LOW);
}

void RedLight(bool status)
{
  return status ? digitalWrite(LED_RED, HIGH) : digitalWrite(LED_RED, LOW);
}

void BlueLight(bool status)
{
  return status ? digitalWrite(LED_BLUE, HIGH) : digitalWrite(LED_BLUE, LOW);
}

void YellowLight(bool status)
{
  return status ? digitalWrite(LED_YELLOW, HIGH) : digitalWrite(LED_YELLOW, LOW);
}

char cmd = 'S';
char prevCmd = 'A';
int velocity = 0;  
unsigned long timer0 = 2000;  //Stores the time (in millis since execution started)
unsigned long timer1 = 0;     //Stores the time when the last command was received from the phone

#endif  // def BT_CAR

void loop() {
  // put your main code here, to run repeatedly:
  // ArduinoOTA.handle();

#ifdef BT_CAR  
  delay(1);

  if (Serial.available()) {
    SerialBT.write(Serial.read());
  }
  if (SerialBT.available()) {
    timer1 = millis();  
    prevCmd = cmd;
    cmd = SerialBT.read();
    //Change pin mode only if new command is different from previous.  
    if(cmd!=prevCmd){
    
      Serial.write(cmd);
      switch(cmd) 
      {
      case 'L' : MotorLeft();break;
      case 'R' : MotorRight();break;  
      case 'F' : MotorUp();break;    
      case 'B' : MotorDown();break;
      case 'X' : MotorStop();break;
      case 'x' : MotorStop();break;
      case 'W' : BlueLight(true);break;
      case 'w' : BlueLight(false);break;
      case 'U' : RedLight(true);break;
      case 'u' : RedLight(false);break;
      case 'V' : YellowLight(true);break;
      case 'v' : YellowLight(false);break;
      default : break;
      }
    }
  }
  delay(1);
#endif // def BT_CAR  
}
